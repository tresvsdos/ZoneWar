<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zone Wars - Card Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');

  :root {
    --bg: #0d0d12;
    --surface: #13131c;
    --surface2: #1a1a28;
    --border: #2a2a40;
    --gold: #c9a84c;
    --gold2: #e8c96a;
    --red: #c94c4c;
    --blue: #4c7bc9;
    --green: #4cb87a;
    --text: #e8e0d0;
    --muted: #7a7a9a;
    --zone1: #c94c4c;
    --zone2: #4c7bc9;
    --zone3: #9b4cc9;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Crimson Text', serif;
    font-size: 16px;
    min-height: 100vh;
    overflow-x: hidden;
  }

  h1, h2, h3, .label {
    font-family: 'Cinzel', serif;
  }

  header {
    text-align: center;
    padding: 16px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }

  header h1 {
    font-size: 1.8rem;
    color: var(--gold);
    letter-spacing: 4px;
  }

  /* Rules button */
  #rulesBtn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 48px;
    height: 48px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.4rem;
    z-index: 40;
    transition: border-color 0.2s, box-shadow 0.2s;
    box-shadow: 0 2px 12px rgba(0,0,0,0.4);
  }
  #rulesBtn:hover {
    border-color: var(--gold);
    box-shadow: 0 2px 20px rgba(201,168,76,0.3);
  }

  /* Rules panel */
  #rulesPanel {
    position: fixed;
    bottom: 80px;
    right: 20px;
    width: 320px;
    max-height: 75vh;
    overflow-y: auto;
    background: var(--surface);
    border: 1px solid var(--gold);
    border-radius: 10px;
    padding: 18px 20px;
    z-index: 41;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    display: none;
  }
  #rulesPanel h3 {
    color: var(--gold);
    font-size: 0.9rem;
    letter-spacing: 3px;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
  }
  #rulesPanel h4 {
    color: var(--gold2);
    font-size: 0.75rem;
    letter-spacing: 2px;
    margin: 12px 0 6px;
  }
  .rule-item {
    font-size: 0.82rem;
    color: var(--text);
    line-height: 1.5;
    margin-bottom: 5px;
    padding-left: 10px;
    border-left: 2px solid var(--border);
  }
  .hand-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid rgba(255,255,255,0.04);
    font-size: 0.8rem;
  }
  .hand-row .hand-name { color: var(--text); }
  .hand-row .hand-pts { color: var(--gold2); font-family: 'Cinzel', serif; font-size: 0.75rem; }
  .hand-row .hand-pts-sum { color: var(--muted); font-size: 0.7rem; }

  .game-info {
    display: flex;
    justify-content: center;
    gap: 24px;
    font-size: 0.85rem;
    margin-top: 6px;
    color: var(--muted);
    font-family: 'Cinzel', serif;
  }

  .game-info span { color: var(--gold2); }

  main {
    max-width: 1100px;
    margin: 0 auto;
    padding: 16px;
  }

  /* ZONES */
  .zones-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin-bottom: 16px;
  }

  .zone {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    position: relative;
    transition: border-color 0.3s;
  }

  .zone.zone-0 { border-top: 3px solid var(--zone1); }
  .zone.zone-1 { border-top: 3px solid var(--zone2); }
  .zone.zone-2 { border-top: 3px solid var(--zone3); }

  .zone.locked {
    opacity: 0.5;
    filter: grayscale(0.8);
  }

  .zone-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .zone-title {
    font-family: 'Cinzel', serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
  }

  .zone-0 .zone-title { color: var(--zone1); }
  .zone-1 .zone-title { color: var(--zone2); }
  .zone-2 .zone-title { color: var(--zone3); }

  .zone-status {
    font-size: 0.7rem;
    font-family: 'Cinzel', serif;
    padding: 2px 6px;
    border-radius: 3px;
    background: var(--surface2);
    color: var(--muted);
  }

  /* Card flip animation */
  .card-flip-wrapper {
    perspective: 400px;
  }

  .card-flip-inner {
    position: relative;
    width: 40px;
    height: 56px;
    transform-style: preserve-3d;
    animation: flipCard 0.5s ease forwards;
  }

  @keyframes flipCard {
    0%   { transform: rotateY(0deg); }
    49%  { transform: rotateY(90deg); }
    50%  { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
  }

  .card-flip-inner.delay-1 { animation-delay: 0.1s; opacity:0; animation-fill-mode: forwards; }
  .card-flip-inner.delay-2 { animation-delay: 0.25s; opacity:0; animation-fill-mode: forwards; }
  .card-flip-inner.delay-3 { animation-delay: 0.4s; opacity:0; animation-fill-mode: forwards; }
  .card-flip-inner.delay-4 { animation-delay: 0.55s; opacity:0; animation-fill-mode: forwards; }

  @keyframes flipCard {
    0%   { transform: rotateY(90deg); opacity:1; }
    100% { transform: rotateY(0deg); opacity:1; }
  }

  /* Round banner */
  #roundBanner {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 50;
  }

  .round-banner-text {
    font-family: 'Cinzel', serif;
    font-size: 2.8rem;
    font-weight: 900;
    color: var(--gold);
    letter-spacing: 8px;
    text-transform: uppercase;
    text-shadow: 0 0 40px rgba(201,168,76,0.8), 0 2px 0 #000;
    animation: bannerAnim 1.6s ease forwards;
    opacity: 0;
  }

  @keyframes bannerAnim {
    0%   { opacity: 0; transform: scale(0.7); }
    20%  { opacity: 1; transform: scale(1.05); }
    60%  { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.1); }
  }

  /* Player rows in zone */
  .zone-players {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .player-row {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .player-row-label {
    font-size: 0.72rem;
    color: var(--muted);
    font-family: 'Cinzel', serif;
    letter-spacing: 1px;
  }

  .cards-area {
    display: flex;
    gap: 4px;
    min-height: 64px;
    background: var(--surface2);
    border-radius: 4px;
    padding: 4px;
    flex-wrap: wrap;
    align-items: center;
  }

  .card-slot {
    width: 40px;
    height: 56px;
    border: 1px dashed var(--border);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.6rem;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.2s;
  }

  .card-slot:hover {
    border-color: var(--gold);
    color: var(--gold);
  }

  .card-slot.filled {
    border-style: solid;
    cursor: default;
  }

  .playing-card {
    width: 40px;
    height: 56px;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
    font-weight: 700;
    border: 1px solid;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    background: #f5f0e8;
    user-select: none;
  }

  .playing-card.face-down {
    background: linear-gradient(135deg, #1e2a4a 25%, #2a3a6a 50%, #1e2a4a 75%);
    border-color: #3a4a7a;
    cursor: default;
  }

  .playing-card.face-down::after {
    content: 'ðŸ‚ ';
    font-size: 1.4rem;
    color: rgba(255,255,255,0.3);
  }

  .playing-card.red { color: #c41a1a; border-color: #daa; }
  .playing-card.black { color: #111; border-color: #aaa; }

  .playing-card.selected {
    transform: translateY(-6px);
    box-shadow: 0 4px 12px rgba(201,168,76,0.5);
    border-color: var(--gold) !important;
  }

  .playing-card.placed-this-round {
    box-shadow: 0 0 8px rgba(201,168,76,0.4);
  }

  .card-suit { font-size: 0.9rem; line-height: 1; }
  .card-val { font-size: 0.75rem; line-height: 1; font-weight: 900; }

  .zone-scores {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 0.72rem;
    padding-top: 8px;
    border-top: 1px solid var(--border);
  }

  .score-item {
    text-align: center;
  }

  .score-item .val {
    font-family: 'Cinzel', serif;
    font-size: 1rem;
    color: var(--gold2);
  }

  .score-item .lbl {
    color: var(--muted);
    font-size: 0.65rem;
  }

  .combo-label {
    font-size: 0.65rem;
    color: var(--muted);
    text-align: center;
    margin-top: 2px;
    font-style: italic;
  }

  /* HAND */
  .hand-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
  }

  .hand-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }

  .hand-title {
    font-family: 'Cinzel', serif;
    font-size: 0.9rem;
    color: var(--gold);
    letter-spacing: 2px;
  }

  .hand-cards {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    min-height: 56px;
  }

  .hand-playing-card {
    width: 44px;
    height: 62px;
    font-size: 0.9rem;
  }

  /* CONTROLS */
  .controls {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }

  .btn {
    font-family: 'Cinzel', serif;
    font-size: 0.75rem;
    letter-spacing: 1px;
    padding: 8px 16px;
    border-radius: 4px;
    border: 1px solid;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  .btn-gold {
    background: var(--gold);
    border-color: var(--gold2);
    color: #1a1208;
  }
  .btn-gold:hover { background: var(--gold2); }

  .btn-outline {
    background: transparent;
    border-color: var(--border);
    color: var(--text);
  }
  .btn-outline:hover { border-color: var(--gold); color: var(--gold); }

  .btn-danger {
    background: transparent;
    border-color: var(--red);
    color: var(--red);
  }
  .btn-danger:hover { background: rgba(201,76,76,0.15); }

  .btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .status-bar {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 14px;
    font-size: 0.85rem;
    color: var(--gold2);
    text-align: center;
    margin-bottom: 12px;
    font-family: 'Cinzel', serif;
    letter-spacing: 1px;
  }

  /* LOG */
  .log-section {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    max-height: 90px;
    overflow-y: auto;
    font-size: 0.8rem;
    color: var(--muted);
  }

  .log-entry { margin-bottom: 2px; }
  .log-entry.important { color: var(--gold2); }
  .log-entry.enemy { color: #7a9ac9; }

  /* OVERLAY */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }

  .overlay-box {
    background: var(--surface);
    border: 1px solid var(--gold);
    border-radius: 12px;
    padding: 32px 40px;
    text-align: center;
    max-width: 420px;
  }

  .overlay-box h2 {
    color: var(--gold);
    font-size: 1.8rem;
    margin-bottom: 12px;
    letter-spacing: 3px;
  }

  .overlay-box p {
    color: var(--muted);
    margin-bottom: 20px;
    font-size: 1.1rem;
    line-height: 1.6;
  }

  .scores-breakdown {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 16px 0;
    text-align: center;
  }

  .score-zone-box {
    background: var(--surface2);
    border-radius: 6px;
    padding: 8px;
    font-size: 0.8rem;
  }

  .score-zone-box .zone-name {
    font-family: 'Cinzel', serif;
    font-size: 0.7rem;
    margin-bottom: 4px;
  }

  .score-zone-box .pts { font-size: 1.2rem; color: var(--gold2); font-family: 'Cinzel', serif; }
  .score-zone-box .winner-tag { color: var(--green); font-size: 0.65rem; }

  .divider {
    width: 100%;
    height: 1px;
    background: var(--border);
    margin: 8px 0;
  }

  .cards-played-info {
    font-size: 0.8rem;
    color: var(--muted);
    padding: 3px 10px;
    background: var(--surface2);
    border-radius: 4px;
  }

  .instruction-text {
    font-size: 0.8rem;
    color: var(--muted);
    font-style: italic;
  }

  /* Mouse drag & drop */
  .draggable-card { cursor: grab; }
  .draggable-card:hover { transform: translateY(-3px); }
  .draggable-card.dragging-ghost { opacity: 0.3; cursor: grabbing; }

  .cards-area.drop-target {
    background: rgba(201,168,76,0.12);
    outline: 2px dashed var(--gold);
    outline-offset: -2px;
  }

  .hand-cards.drop-target-hand {
    background: rgba(76,184,122,0.08);
    outline: 2px dashed var(--green);
    outline-offset: -2px;
    border-radius: 4px;
  }

  /* Discard zone */
  .discard-area {
    width: 176px;
    min-height: 68px;
    border: 2px dashed var(--border);
    border-radius: 6px;
    background: var(--surface2);
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    padding: 4px;
    transition: border-color 0.2s, background 0.2s;
  }
  .discard-area.drop-target-discard {
    border-color: var(--gold);
    background: rgba(201,168,76,0.1);
  }
  .discard-area.full {
    border-color: var(--muted);
    opacity: 0.5;
  }

  .playing-card.retractable {
    outline: 1px dashed rgba(201,168,76,0.5);
  }
  .playing-card.retractable:hover {
    outline-color: var(--gold);
  }

  /* Floating drag card */
  #dragGhost {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    opacity: 0.92;
    transform: rotate(4deg) scale(1.08);
    transition: none;
  }
</style>
</head>
<body>

<header>
  <h1>âš” ZONE WARS âš”</h1>
  <div class="game-info">
    Ronda: <span id="roundDisplay">1</span> &nbsp;|&nbsp;
    Fase: <span id="phaseDisplay">Tu turno</span>
  </div>
</header>

<main>
  <div class="status-bar" id="statusBar">Selecciona 2 cartas y colÃ³calas en las zonas</div>

  <div class="zones-row" id="zonesRow"></div>

  <div class="hand-section">
    <div class="hand-header">
      <span class="hand-title">Tu Mano</span>
      <div class="controls">
        <span class="cards-played-info" id="cardsPlayedInfo">0 / 2 cartas jugadas</span>
        <button class="btn btn-gold" id="endRoundBtn" onclick="endRound()">Terminar Ronda â†’</button>
      </div>
    </div>
    <div style="display:flex; gap:12px; align-items:flex-start;">
      <div class="hand-cards" id="handCards" style="flex:1;"></div>
      <div id="discardZone" style="flex-shrink:0;">
        <div class="player-row-label" style="margin-bottom:4px; text-align:center;"> DESCARTE <span id="swapCountLabel">(2 restantes)</span></div>
        <div class="discard-area" id="discardArea" data-drop-discard="1"></div>
      </div>
    </div>
    <div class="instruction-text" style="margin-top:6px;" id="instrText">Arrastra cartas a las zonas. Arrastra al Ã¡rea de descarte para cambiarlas (mÃ¡x. 2/ronda). Las cartas de esta ronda en zona se pueden arrastrar de vuelta.</div>
  </div>

  <div class="log-section" id="gameLog">
    <div class="log-entry important">Â¡Bienvenido a Zone Wars! La Zona 1 estÃ¡ activa.</div>
  </div>
</main>

<!-- End Game Overlay -->
<div class="overlay" id="endOverlay" style="display:none;">
  <div class="overlay-box">
    <h2 id="endTitle">Â¡Victoria!</h2>
    <div class="scores-breakdown" id="endScores"></div>
    <p id="endMsg"></p>
    <button class="btn btn-gold" onclick="startGame()">Nueva Partida</button>
  </div>
</div>

<!-- Round banner (no interaction) -->
<div id="roundBanner" style="display:none;">
  <div class="round-banner-text" id="roundBannerText"></div>
</div>

<!-- Floating drag ghost -->
<div id="dragGhost" style="display:none;"></div>

<!-- Rules button -->
<button id="rulesBtn" onclick="toggleRules()" title="Reglas del juego">ðŸ“‹</button>

<!-- Rules panel -->
<div id="rulesPanel">
  <h3>ðŸ“‹ REGLAS DEL JUEGO</h3>

  <h4>ESTRUCTURA</h4>
  <div class="rule-item">La partida tiene <b>4 rondas</b>. Cada ronda desbloquea una nueva zona (rondas 1-3). La ronda 4 es la ronda final con todas las zonas activas.</div>
  <div class="rule-item">Cada zona tiene <b>2 cartas comunitarias</b> que forman parte de la mano de ambos jugadores.</div>
  <div class="rule-item">Cada jugador puede aÃ±adir hasta <b>4 cartas propias</b> a cada zona (mano final: 6 cartas).</div>

  <h4>TURNO</h4>
  <div class="rule-item">Rondas 1-3: juega <b>2 cartas</b> por ronda. Ronda final: juega <b>3 cartas</b>.</div>
  <div class="rule-item">Las cartas del rival se revelan <b>al terminar la ronda</b> (se colocan boca abajo).</div>
  <div class="rule-item">Puedes seguir aÃ±adiendo cartas a zonas anteriores mientras no estÃ©n llenas.</div>
  <div class="rule-item">Las cartas jugadas en la <b>ronda actual</b> se pueden retirar arrastrÃ¡ndolas de vuelta a la mano.</div>
  <div class="rule-item">Al final de cada ronda (excepto la 4Âª) recibes <b>2 cartas nuevas</b>.</div>

  <h4>DESCARTE</h4>
  <div class="rule-item">Arrastra una carta al Ã¡rea de descarte (â†©) para cambiarla por otra aleatoria. <b>MÃ¡ximo 2 cambios por ronda.</b></div>

  <h4>VICTORIA</h4>
  <div class="rule-item">Gana quien consiga <b>2 o mÃ¡s zonas</b>. En caso de empate (1-1-empate), gana quien tenga mÃ¡s <b>puntos totales</b>.</div>
  <div class="rule-item">PuntuaciÃ³n de zona = <b>Combo + Suma de valores</b> de todas las cartas (comunitarias + propias).</div>

  <h4>MANOS (COMBO)</h4>
  <div class="hand-row"><span class="hand-name">Straight Flush</span><span class="hand-pts">120 pts</span></div>
  <div class="hand-row"><span class="hand-name">Four Knights (pÃ³ker)</span><span class="hand-pts">80 pts</span></div>
  <div class="hand-row"><span class="hand-name">Straight (escalera)</span><span class="hand-pts">60 pts</span></div>
  <div class="hand-row"><span class="hand-name">Flush (color)</span><span class="hand-pts">60 pts</span></div>
  <div class="hand-row"><span class="hand-name">Full House</span><span class="hand-pts">55 pts</span></div>
  <div class="hand-row"><span class="hand-name">Doble Pareja</span><span class="hand-pts">30 pts</span></div>
  <div class="hand-row"><span class="hand-name">TrÃ­o</span><span class="hand-pts">30 pts</span></div>
  <div class="hand-row"><span class="hand-name">Pareja</span><span class="hand-pts">15 pts</span></div>
  <div class="hand-row"><span class="hand-name">Carta Alta</span><span class="hand-pts hand-pts-sum">valor de la carta</span></div>

  <h4>VALORES DE CARTA</h4>
  <div class="rule-item">2=2, 3=3 ... 10=10, J=11, Q=12, K=13, A=14</div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

<script>
  // Your web app's Firebase configuration
  const firebaseConfig = {
    "projectId": "zonewar-multijugador",
    "appId": "1:143988812857:web:189410f2bf5c4b8c1371e8",
    "storageBucket": "zonewar-multijugador.firebasestorage.app",
    "apiKey": "AIzaSyAVcYR8ibaIrkFWHEi54_xeY73LCZHJNdg",
    "authDomain": "zonewar-multijugador.firebaseapp.com",
    "messagingSenderId": "143988812857",
    "measurementId": "G-YZGFN1M3PH"
  };

  // Initialize Firebase
  const app = firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  // Sign in anonymously and start the game
  auth.signInAnonymously()
    .then((userCredential) => {
      console.log('Signed in anonymously:', userCredential.user.uid);
      addLog('Conectado al servidor multijugador.', true);
      // We can now start the game logic that depends on Firebase
      // For now, the existing startGame() is called at the end of the file.
      // We might want to move it here later.
    })
    .catch((error) => {
      console.error("Error signing in anonymously:", error);
      addLog('Error de conexiÃ³n. Jugando en modo local.', true);
    });

</script>

<script>
// â”€â”€ RULES PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function toggleRules() {
  const panel = document.getElementById('rulesPanel');
  panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

// Close panel when clicking outside
document.addEventListener('mousedown', (e) => {
  const panel = document.getElementById('rulesPanel');
  const btn = document.getElementById('rulesBtn');
  if (panel.style.display === 'block' && !panel.contains(e.target) && !btn.contains(e.target)) {
    panel.style.display = 'none';
  }
});

// â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SUITS = ['â™ ','â™¥','â™¦','â™£'];
const VALUES = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const SUIT_COLOR = { 'â™ ':'black','â™£':'black','â™¥':'red','â™¦':'red' };
const VAL_MAP = {'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':11,'Q':12,'K':13,'A':14};
const MAX_SWAPS = 2;
const CARDS_PER_ROUND = 2; // last round: 3
const TOTAL_ROUNDS = 4;
const ZONE_CAPACITY = 4;

let deck = [];
let playerHand = [];
let enemyHand = [];
let zones = []; // [{communityCards:[], playerCards:[], enemyCards:[]}]
let round = 1;
let swapsUsed = 0; // swaps used this round (max MAX_SWAPS)
let cardsPlayedThisRound = 0;
let cardsToPlayThisRound = 2;
let phase = 'playing'; // 'playing' | 'reveal'
let enemyPlacedThisRound = []; // [{zoneIdx, card}]
let revealingEnemyCards = false;
let revealedEnemyCardIds = new Set(); // cards already shown face-up from previous rounds

// Drag & drop state (mouse-based) â€” declared in drag system below
let thisRoundPlaced = []; // [{card, zoneIdx}] â€” placed this round, can be retracted

// â”€â”€ DECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function makeDeck() {
  const d = [];
  for (const s of SUITS) for (const v of VALUES) d.push({suit:s, val:v});
  return d;
}

function shuffle(arr) {
  // Use crypto.getRandomValues for better entropy if available
  const rand = (n) => {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const buf = new Uint32Array(1);
      crypto.getRandomValues(buf);
      return buf[0] % n;
    }
    return Math.floor(Math.random() * n);
  };
  // Fisher-Yates with 3 passes for better mixing
  for (let pass = 0; pass < 3; pass++) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = rand(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  return arr;
}

function drawCard() {
  if (!deck.length) return null;
  // Draw from a random position, not always the end
  const idx = Math.floor(Math.random() * deck.length);
  return deck.splice(idx, 1)[0];
}

// â”€â”€ COMBINATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function cardNum(c) { return VAL_MAP[c.val]; }

function evalHand(cards) {
  // Evaluate a hand of any size, return best combo
  if (!cards.length) return {name:'â€”', pts:0};
  const n = cards.length;
  const vals = cards.map(cardNum).sort((a,b)=>a-b);
  const suits = cards.map(c=>c.suit);
  const valsSet = {};
  vals.forEach(v => valsSet[v] = (valsSet[v]||0)+1);
  const counts = Object.values(valsSet).sort((a,b)=>b-a);

  const isFlush = n >= 4 && suits.every(s=>s===suits[0]);
  const isStraight = n >= 4 && (() => {
    const u = [...new Set(vals)].sort((a,b)=>a-b);
    if (u.length < 4) return false;
    for (let i=0; i<=u.length-4; i++) {
      let ok = true;
      for (let j=1; j<4; j++) if (u[i+j]-u[i+j-1]!==1) {ok=false;break;}
      if (ok) return true;
    }
    return false;
  })();

  if (n>=4 && isFlush && isStraight) return {name:'Straight Flush', pts:120};
  if (counts[0]===4) return {name:'Four Knights', pts:80};
  if (isStraight) return {name:'Straight', pts:60};
  if (isFlush) return {name:'Flush', pts:60};
  if (counts[0]===3 && counts[1]>=2) return {name:'Full House', pts:55};
  if (counts[0]===3) return {name:'TrÃ­o', pts:30};
  if (counts[0]===2 && counts[1]===2) return {name:'Doble Pareja', pts:30};
  if (counts[0]===2) return {name:'Pareja', pts:15};
  return {name:'Carta Alta', pts: Math.max(...vals)};
}

function bestCombo(cards) {
  if (!cards.length) return {name:'â€”', pts:0};
  // With 5 or fewer cards evaluate directly
  if (cards.length <= 5) return evalHand(cards);
  // With 6 cards, try all C(6,5)=6 subsets of 5 and pick best
  // Also try the full 6-card hand
  const HAND_RANK = {'Straight Flush':8,'Four Knights':7,'Straight':6,'Flush':6,'Full House':5,'TrÃ­o':4,'Doble Pareja':3,'Pareja':2,'Carta Alta':1,'â€”':0};
  let best = evalHand(cards); // full hand first
  for (let skip=0; skip < cards.length; skip++) {
    const sub = cards.filter((_,i)=>i!==skip);
    const h = evalHand(sub);
    if ((HAND_RANK[h.name]||0) > (HAND_RANK[best.name]||0)) best = h;
    else if ((HAND_RANK[h.name]||0) === (HAND_RANK[best.name]||0) && h.pts > best.pts) best = h;
  }
  return best;
}

function pointSum(cards) {
  return cards.reduce((s,c) => s+cardNum(c), 0);
}

// fullHand = communityCards + playerCards (or enemyCards)
function totalScore(communityCards, extraCards) {
  const all = [...communityCards, ...extraCards];
  if (!all.length) return 0;
  const combo = bestCombo(all);
  return combo.pts + pointSum(all);
}

function totalScoreAll(communityCards, extraCards) {
  const all = [...communityCards, ...extraCards];
  return { combo: bestCombo(all), sum: pointSum(all), total: totalScore(communityCards, extraCards) };
}

// â”€â”€ AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function aiPlayCards() {
  enemyPlacedThisRound = [];
  const toPlay = cardsToPlayThisRound;
  let placed = 0;
  
  for (let p = 0; p < toPlay && placed < toPlay; p++) {
    if (!enemyHand.length) break;
    
    const candidates = [];
    for (let zi = 0; zi < 3; zi++) {
      if (zi >= Math.min(round, 3)) continue; // zone not unlocked
      if (zones[zi].enemyCards.length >= ZONE_CAPACITY) continue;
      for (let ci = 0; ci < enemyHand.length; ci++) {
        const testExtra = [...zones[zi].enemyCards, enemyHand[ci]];
        const score = totalScore(zones[zi].communityCards, testExtra);
        candidates.push({zi, ci, score});
      }
    }
    
    if (!candidates.length) break;
    candidates.sort((a,b) => b.score - a.score);
    const pick = candidates[0];
    
    const card = enemyHand.splice(pick.ci, 1)[0];
    zones[pick.zi].enemyCards.push(card);
    enemyPlacedThisRound.push({zoneIdx: pick.zi, card});
    placed++;
    
    const drawn = drawCard();
    if (drawn) enemyHand.push(drawn);
  }
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function startGame() {
  deck = shuffle(makeDeck());
  playerHand = [];
  enemyHand = [];
  zones = [0,1,2].map(() => ({
    communityCards: [drawCard(), drawCard()],
    playerCards: [],
    enemyCards: [],
  }));
  round = 1;
  swapsUsed = 0;
  cardsPlayedThisRound = 0;
  cardsToPlayThisRound = 2;
  phase = 'playing';
  enemyPlacedThisRound = [];
  revealedEnemyCardIds = new Set();
  thisRoundPlaced = [];
  md = null;
  dropTarget = null;

  // Deal initial hands (5 cards each)
  for (let i=0;i<5;i++) playerHand.push(drawCard());
  for (let i=0;i<7;i++) enemyHand.push(drawCard());

  document.getElementById('endOverlay').style.display='none';
  document.getElementById('roundBanner').style.display='none';
  revealingEnemyCards = false;

  clearLog();
  addLog('Â¡Nueva partida! Ronda 1 â€” Zona 1 desbloqueada.', true);
  render();
}

// â”€â”€ ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function doPlaceCard(handIdx, zoneIdx) {
  const zone = zones[zoneIdx];
  if (zone.playerCards.length >= ZONE_CAPACITY) { addLog('Zona llena.'); return false; }
  if (zoneIdx >= Math.min(round, 3)) { addLog(`Zona ${zoneIdx+1} no desbloqueada.`); return false; }
  if (cardsPlayedThisRound >= cardsToPlayThisRound) { addLog('Ya jugaste todas las cartas de esta ronda.'); return false; }
  const card = playerHand.splice(handIdx, 1)[0];
  zone.playerCards.push(card);
  thisRoundPlaced.push({ card, zoneIdx });
  cardsPlayedThisRound++;
  addLog(`Colocaste ${card.val}${card.suit} en Zona ${zoneIdx+1}.`);
  return true;
}

function doRetractCard(zoneIdx, cardIdx) {
  const card = zones[zoneIdx].playerCards[cardIdx];
  const placedIdx = thisRoundPlaced.findIndex(p => p.card === card && p.zoneIdx === zoneIdx);
  if (placedIdx === -1) return false;
  zones[zoneIdx].playerCards.splice(cardIdx, 1);
  playerHand.push(card);
  thisRoundPlaced.splice(placedIdx, 1);
  cardsPlayedThisRound--;
  addLog(`Retiraste ${card.val}${card.suit} de Zona ${zoneIdx+1}.`);
  return true;
}

function doDiscardCard(handIdx) {
  if (swapsUsed >= MAX_SWAPS) { addLog('Ya usaste todos los cambios de esta ronda.'); return false; }
  const card = playerHand.splice(handIdx, 1)[0];
  // Draw replacement immediately for discard
  const drawn = drawCard();
  if (!drawn) { playerHand.splice(handIdx, 0, card); addLog('No hay cartas en el mazo.'); return false; }
  playerHand.push(drawn);
  swapsUsed++;
  addLog(`Descartaste ${card.val}${card.suit} â†’ recibiste ${drawn.val}${drawn.suit}. Cambios restantes: ${MAX_SWAPS - swapsUsed}.`);
  return true;
}

function endRound() {
  if (phase !== 'playing') return;
  if (cardsPlayedThisRound < cardsToPlayThisRound) {
    const canPlace = zones.some((z,i) => i < Math.min(round, 3) && z.playerCards.length < ZONE_CAPACITY);
    if (canPlace) {
      addLog(`Debes jugar ${cardsToPlayThisRound - cardsPlayedThisRound} carta(s) mÃ¡s antes de terminar la ronda.`);
      return;
    }
  }

  phase = 'reveal';
  aiPlayCards();

  document.getElementById('endRoundBtn').disabled = true;

  revealEnemyCardsAnimated(() => {
    if (round >= TOTAL_ROUNDS) {
      setTimeout(() => endGame(), 600);
    } else {
      setTimeout(() => startNextRound(), 500);
    }
  });
}

// â”€â”€ MOUSE DRAG & DROP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let md = null; // active drag: { source, card, startX, startY, ghost }
let dropTarget = null; // 'hand' | zoneIdx number

const ghost = document.getElementById('dragGhost');

function startDragFromHand(e, idx) {
  if (phase !== 'playing') return;
  e.preventDefault();
  const card = playerHand[idx];
  md = { source: { type: 'hand', idx }, card };
  beginDrag(e, card);
}

function startDragFromZone(e, zoneIdx, cardIdx) {
  if (phase !== 'playing') return;
  const card = zones[zoneIdx].playerCards[cardIdx];
  if (!thisRoundPlaced.some(p => p.card === card && p.zoneIdx === zoneIdx)) return;
  e.preventDefault();
  md = { source: { type: 'zone', zoneIdx, cardIdx, card }, card };
  beginDrag(e, card);
}

function beginDrag(e, card) {
  // Build ghost card
  const color = SUIT_COLOR[card.suit];
  ghost.className = `playing-card ${color}`;
  ghost.style.display = 'flex';
  ghost.style.width = '44px';
  ghost.style.height = '62px';
  ghost.style.fontSize = '0.9rem';
  ghost.style.fontWeight = '700';
  ghost.style.flexDirection = 'column';
  ghost.style.alignItems = 'center';
  ghost.style.justifyContent = 'center';
  ghost.style.background = '#f5f0e8';
  ghost.style.border = `1px solid ${color === 'red' ? '#daa' : '#aaa'}`;
  ghost.style.borderRadius = '4px';
  ghost.innerHTML = `<div style="font-size:.75rem;font-weight:900;line-height:1">${card.val}</div><div style="font-size:.9rem;line-height:1;color:${color === 'red' ? '#c41a1a' : '#111'}">${card.suit}</div>`;
  positionGhost(e);
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
  document.body.style.userSelect = 'none';
  render();
}

function positionGhost(e) {
  ghost.style.left = (e.clientX - 22) + 'px';
  ghost.style.top  = (e.clientY - 31) + 'px';
}

function onMouseMove(e) {
  if (!md) return;
  positionGhost(e);

  // Hit-test drop targets
  ghost.style.display = 'none'; // hide ghost so elementFromPoint works
  const el = document.elementFromPoint(e.clientX, e.clientY);
  ghost.style.display = 'flex';

  let newTarget = null;
  if (el) {
    // Zone drop areas (hand â†’ zone)
    const zoneArea = el.closest('[data-drop-zone]');
    if (zoneArea && md.source.type === 'hand') {
      const zi = parseInt(zoneArea.dataset.dropZone);
      if (zi < Math.min(round, 3) && zones[zi].playerCards.length < ZONE_CAPACITY)
        newTarget = zi;
    }
    // Hand drop area (zone â†’ hand retract)
    const handArea = el.closest('[data-drop-hand]');
    if (handArea && md.source.type === 'zone') newTarget = 'hand';
    // Discard drop area (hand â†’ discard)
    const discardArea = el.closest('[data-drop-discard]');
    if (discardArea && md.source.type === 'hand' && swapsUsed < MAX_SWAPS) newTarget = 'discard';
  }

  if (newTarget !== dropTarget) { dropTarget = newTarget; render(); }
}

function onMouseUp(e) {
  document.removeEventListener('mousemove', onMouseMove);
  document.removeEventListener('mouseup', onMouseUp);
  document.body.style.userSelect = '';
  ghost.style.display = 'none';

  if (md && dropTarget !== null) {
    if (typeof dropTarget === 'number' && md.source.type === 'hand') {
      doPlaceCard(md.source.idx, dropTarget);
    } else if (dropTarget === 'hand' && md.source.type === 'zone') {
      doRetractCard(md.source.zoneIdx, md.source.cardIdx);
    } else if (dropTarget === 'discard' && md.source.type === 'hand') {
      doDiscardCard(md.source.idx);
    }
  }

  md = null; dropTarget = null;
  render();
}

function endRound() {
  if (phase !== 'playing') return;
  if (cardsPlayedThisRound < cardsToPlayThisRound) {
    const canPlace = zones.some((z,i) => i < Math.min(round, 3) && z.playerCards.length < ZONE_CAPACITY);
    if (canPlace) {
      addLog(`Debes jugar ${cardsToPlayThisRound - cardsPlayedThisRound} carta(s) mÃ¡s antes de terminar la ronda.`);
      return;
    }
  }

  phase = 'reveal';
  aiPlayCards();

  document.getElementById('endRoundBtn').disabled = true;

  revealEnemyCardsAnimated(() => {
    // 2) After flip, if game over go to end, else show new round banner
    if (round >= TOTAL_ROUNDS) {
      setTimeout(() => endGame(), 600);
    } else {
      setTimeout(() => startNextRound(), 500);
    }
  });
}

function revealEnemyCardsAnimated(onDone) {
  // Mark all enemy cards as "revealing" so renderZones knows to animate them
  revealingEnemyCards = true;
  render();

  // Total animation time: last card flips at ~0.55s + 0.5s anim = ~1.1s
  const totalCards = enemyPlacedThisRound.length;
  const duration = totalCards > 0 ? (totalCards - 1) * 150 + 600 : 400;
  setTimeout(() => {
    revealingEnemyCards = false;
    // Mark all placed cards as permanently revealed
    for (const move of enemyPlacedThisRound) {
      revealedEnemyCardIds.add(move.card);
    }
    onDone();
  }, duration);
}

function startNextRound() {
  round++;
  cardsPlayedThisRound = 0;
  cardsToPlayThisRound = round === TOTAL_ROUNDS ? 3 : 2;
  phase = 'playing';
  enemyPlacedThisRound = [];
  thisRoundPlaced = [];
  swapsUsed = 0;
  md = null;

  // Draw new cards for this round (not in round 4)
  if (round < TOTAL_ROUNDS) {
    const toDraw = cardsToPlayThisRound; // 2 cards
    for (let i = 0; i < toDraw; i++) {
      const c = drawCard();
      if (c) playerHand.push(c);
    }
    addLog(`Robaste ${toDraw} cartas nuevas.`);
  }

  const label = round === TOTAL_ROUNDS ? `RONDA FINAL` : `RONDA ${round}`;
  showRoundBanner(label, () => {
    const unlockMsg = round <= 3
      ? ` Zona ${round} desbloqueada.`
      : ' Â¡Ronda final! Todas las zonas activas.';
    addLog(`Ronda ${round} iniciada.${unlockMsg}`, true);
    if (round === TOTAL_ROUNDS) addLog('Ronda final: juega 3 cartas.', true);
    render();
  });
}

function showRoundBanner(text, onDone) {
  const banner = document.getElementById('roundBanner');
  const bannerText = document.getElementById('roundBannerText');
  bannerText.textContent = text;
  // Reset animation
  bannerText.style.animation = 'none';
  bannerText.offsetHeight; // reflow
  bannerText.style.animation = '';
  banner.style.display = 'flex';
  render(); // update zones (new zone unlocked)
  setTimeout(() => {
    banner.style.display = 'none';
    onDone();
  }, 1700);
}

function endGame() {
  let playerWins = 0, enemyWins = 0;
  let playerTotal = 0, enemyTotal = 0;
  
  const breakdown = [];
  for (let i=0;i<3;i++) {
    const pS = totalScore(zones[i].communityCards, zones[i].playerCards);
    const eS = totalScore(zones[i].communityCards, zones[i].enemyCards);
    playerTotal += pS;
    enemyTotal += eS;
    if (pS > eS) { playerWins++; breakdown.push({zone:i, winner:'player', pS, eS}); }
    else if (eS > pS) { enemyWins++; breakdown.push({zone:i, winner:'enemy', pS, eS}); }
    else { breakdown.push({zone:i, winner:'tie', pS, eS}); }
  }
  
  let winner = 'tie';
  if (playerWins >= 2) winner = 'player';
  else if (enemyWins >= 2) winner = 'enemy';
  else if (playerTotal > enemyTotal) winner = 'player';
  else if (enemyTotal > playerTotal) winner = 'enemy';
  
  const titles = {player:'Â¡Victoria!', enemy:'Â¡Derrota!', tie:'Â¡Empate!'};
  const msgs = {
    player:`Ganaste ${playerWins} zonas. PuntuaciÃ³n total: TÃº ${playerTotal} â€” Enemigo ${enemyTotal}`,
    enemy:`El enemigo ganÃ³ ${enemyWins} zonas. PuntuaciÃ³n total: Enemigo ${enemyTotal} â€” TÃº ${playerTotal}`,
    tie:`Empate total. Puntos: TÃº ${playerTotal} â€” Enemigo ${enemyTotal}`
  };
  
  document.getElementById('endTitle').textContent = titles[winner];
  document.getElementById('endMsg').textContent = msgs[winner];
  
  let scHtml = '';
  for (const b of breakdown) {
    const wColor = b.winner==='player'?'#4cb87a':b.winner==='enemy'?'#c94c4c':'#aaa';
    const wLabel = b.winner==='player'?'TÃš':b.winner==='enemy'?'RIVAL':'EMPATE';
    scHtml += `<div class="score-zone-box">
      <div class="zone-name" style="color:${wColor}">ZONA ${b.zone+1}</div>
      <div style="color:#ccc; font-size:0.8rem;">TÃº: <b>${b.pS}</b></div>
      <div style="color:#7a9ac9; font-size:0.8rem;">Rival: <b>${b.eS}</b></div>
      <div class="winner-tag" style="color:${wColor}">${wLabel}</div>
    </div>`;
  }
  document.getElementById('endScores').innerHTML = scHtml;
  document.getElementById('endOverlay').style.display='flex';
}

// â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function render() {
  renderInfo();
  renderZones();
  renderHand();
}

function renderInfo() {
  document.getElementById('roundDisplay').textContent = round;
  document.getElementById('phaseDisplay').textContent = phase === 'playing' ? 'Tu turno' : 'Revelando...';

  const remaining = cardsToPlayThisRound - cardsPlayedThisRound;
  document.getElementById('cardsPlayedInfo').textContent = `${cardsPlayedThisRound} / ${cardsToPlayThisRound} cartas jugadas`;

  if (phase !== 'playing') {
    document.getElementById('statusBar').textContent = `Revelando jugadas del rival...`;
  } else if (remaining > 0) {
    document.getElementById('statusBar').textContent = `Coloca ${remaining} carta(s) en las zonas (Ronda ${round}/${TOTAL_ROUNDS})`;
  } else {
    document.getElementById('statusBar').textContent = `Listo para terminar la ronda.`;
  }

  document.getElementById('endRoundBtn').disabled = phase !== 'playing';

  // Update discard zone label
  const swapLabel = document.getElementById('swapCountLabel');
  if (swapLabel) swapLabel.textContent = `(${MAX_SWAPS - swapsUsed} restantes)`;

  // Render discard area highlight
  const discardArea = document.getElementById('discardArea');
  if (discardArea) {
    const isTarget = dropTarget === 'discard';
    const isFull = swapsUsed >= MAX_SWAPS;
    discardArea.className = 'discard-area' + (isTarget ? ' drop-target-discard' : '') + (isFull ? ' full' : '');
    discardArea.innerHTML = isFull
      ? `<span style="font-size:0.65rem; color:var(--muted); text-align:center;">Sin cambios</span>`
      : `<span style="font-size:1.5rem; color:var(--muted);">â†©</span>`;
  }

  const instrEl = document.getElementById('instrText');
  if (instrEl) {
    instrEl.textContent = phase !== 'playing'
      ? 'Revelando jugadas del rival...'
      : 'Arrastra cartas a zonas para jugarlas Â· Arrastra al descarte para cambiarlas Â· Las cartas de zona con borde dorado se pueden retirar.';
  }
}

function renderZones() {
  const container = document.getElementById('zonesRow');
  const zoneNames = ['ZONA ROJA','ZONA AZUL','ZONA VIOLETA'];
  let html = '';

  // Track which cards per zone are "newly revealed" this frame
  const newlyRevealedByZone = {};
  if (revealingEnemyCards) {
    let delayIdx = 0;
    for (const move of enemyPlacedThisRound) {
      if (!newlyRevealedByZone[move.zoneIdx]) newlyRevealedByZone[move.zoneIdx] = [];
      newlyRevealedByZone[move.zoneIdx].push({ card: move.card, delayIdx: delayIdx++ });
    }
  }

  for (let i=0;i<3;i++) {
    const z = zones[i];
    const locked = i >= Math.min(round, 3);

    const pScore = totalScore(z.communityCards, z.playerCards);
    const eScore = totalScore(z.communityCards, z.enemyCards);
    const pCombo = bestCombo([...z.communityCards, ...z.playerCards]);
    const eCombo = bestCombo([...z.communityCards, ...z.enemyCards]);

    const statusText = locked ? `ABRE RONDA ${i+1}` : `RONDA ${i+1}+`;

    // Community cards
    const commHtml = locked
      ? `<div class="playing-card face-down"></div><div class="playing-card face-down"></div>`
      : z.communityCards.map(c => cardHtml(c, false, false, 'small')).join('');

    // Enemy cards: face-down during play, animated flip when revealing, face-up after
    let enemyCardsHtml = '';
    const newlyRevealed = newlyRevealedByZone[i] || [];
    const newlyRevealedCards = newlyRevealed.map(n => n.card);

    for (const c of z.enemyCards) {
      const isNew = newlyRevealedCards.some(nc => nc === c);
      const alreadyRevealed = revealedEnemyCardIds.has(c);

      if (revealingEnemyCards && isNew) {
        // Animate flip for this card
        const nr = newlyRevealed.find(n => n.card === c);
        const delayClass = `delay-${nr.delayIdx + 1}`;
        const color = SUIT_COLOR[c.suit];
        enemyCardsHtml += `<div class="card-flip-wrapper">
          <div class="card-flip-inner ${delayClass}">
            <div class="playing-card ${color}">
              <div class="card-val">${c.val}</div><div class="card-suit">${c.suit}</div>
            </div>
          </div>
        </div>`;
      } else if (alreadyRevealed || revealingEnemyCards) {
        // Permanently revealed from a past round â€” always face-up
        enemyCardsHtml += cardHtml(c, false, false, 'small');
      } else {
        // Not yet revealed â€” face down
        enemyCardsHtml += `<div class="playing-card face-down"></div>`;
      }
    }

    html += `<div class="zone zone-${i} ${locked ? 'locked' : ''}" id="zone-${i}">
      <div class="zone-header">
        <span class="zone-title">${zoneNames[i]}</span>
        <span class="zone-status">${statusText}</span>
      </div>

      <div class="zone-players">
        <div class="player-row">
          <div class="player-row-label">RIVAL (${z.enemyCards.length}/${ZONE_CAPACITY})</div>
          <div class="cards-area">${enemyCardsHtml}</div>
          <div class="combo-label">${!locked && (phase !== 'playing' || revealingEnemyCards) && eCombo.name !== 'â€”' ? `${eCombo.name} â€” ${eScore}pts` : ''}</div>
        </div>

        <div style="display:flex; flex-direction:column; align-items:center; gap:3px; padding:6px 0;">
          <div class="player-row-label" style="font-size:0.65rem; letter-spacing:2px;">âš‘ ZONA</div>
          <div style="display:flex; gap:6px; justify-content:center;">${commHtml}</div>
        </div>

        <div class="player-row">
          <div class="player-row-label">TÃš (${z.playerCards.length}/${ZONE_CAPACITY})</div>
          <div class="cards-area ${!locked && dropTarget === i ? 'drop-target' : ''}"
            data-drop-zone="${i}">
            ${z.playerCards.map((c, ci) => {
              const color = SUIT_COLOR[c.suit];
              const isRetractable = phase === 'playing' && thisRoundPlaced.some(p => p.card === c && p.zoneIdx === i);
              const isGhost = md?.source?.type === 'zone' && md.source.zoneIdx === i && md.source.cardIdx === ci;
              return `<div class="playing-card ${color} ${isRetractable ? 'retractable draggable-card' : ''} ${isGhost ? 'dragging-ghost' : ''}"
                onmousedown="${isRetractable ? `startDragFromZone(event, ${i}, ${ci})` : ''}">
                <div class="card-val">${c.val}</div>
                <div class="card-suit">${c.suit}</div>
              </div>`;
            }).join('')}
          </div>
          <div class="combo-label">${locked ? '' : (pCombo.name !== 'â€”' ? `${pCombo.name} â€” ${pCombo.pts}pts` : z.playerCards.length === 0 ? 'Sin cartas' : '')}</div>
        </div>
      </div>`;

    if (!locked) {
      const pComboOnly = bestCombo([...z.communityCards, ...z.playerCards]);
      const pSumOnly   = pointSum([...z.communityCards, ...z.playerCards]);
      html += `<div class="zone-scores">
        <div class="score-item"><div class="val" style="font-size:.85rem">${pComboOnly.pts}</div><div class="lbl">COMBO</div></div>
        <div class="score-item"><div class="val" style="font-size:.85rem; color:var(--muted)">+</div></div>
        <div class="score-item"><div class="val" style="font-size:.85rem">${pSumOnly}</div><div class="lbl">SUMA</div></div>
        <div class="score-item"><div class="val" style="font-size:.85rem; color:var(--muted)">=</div></div>
        <div class="score-item"><div class="val">${pScore}</div><div class="lbl">TOTAL</div></div>
      </div>`;
    }

    html += `</div>`;
  }

  container.innerHTML = html;
}

function cardHtml(card, faceDown, selected, size) {
  if (faceDown) {
    return `<div class="playing-card face-down ${size === 'small' ? '' : 'hand-playing-card'}"></div>`;
  }
  const color = SUIT_COLOR[card.suit];
  const sel = selected ? 'selected' : '';
  return `<div class="playing-card ${color} ${sel} ${size !== 'small' ? 'hand-playing-card' : ''}">
    <div class="card-val">${card.val}</div>
    <div class="card-suit">${card.suit}</div>
  </div>`;
}

function renderHand() {
  const container = document.getElementById('handCards');
  const isDraggingFromHand = md?.source?.type === 'hand';
  container.className = 'hand-cards' + (dropTarget === 'hand' ? ' drop-target-hand' : '');
  container.setAttribute('data-drop-hand', '1');
  container.innerHTML = playerHand.map((c, i) => {
    const color = SUIT_COLOR[c.suit];
    const isGhost = isDraggingFromHand && md.source.idx === i;
    return `<div class="playing-card ${color} hand-playing-card draggable-card ${isGhost ? 'dragging-ghost' : ''}"
      onmousedown="startDragFromHand(event, ${i})">
      <div class="card-val">${c.val}</div>
      <div class="card-suit">${c.suit}</div>
    </div>`;
  }).join('');
}

// â”€â”€ LOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function addLog(msg, important=false) {
  const log = document.getElementById('gameLog');
  const el = document.createElement('div');
  el.className = 'log-entry' + (important ? ' important' : '');
  el.textContent = msg;
  log.prepend(el);
}

function clearLog() {
  document.getElementById('gameLog').innerHTML = '';
}

// â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

startGame();
</script>
</body>
</html>
